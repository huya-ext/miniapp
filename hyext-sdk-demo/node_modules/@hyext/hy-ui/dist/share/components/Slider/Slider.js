function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import React, { PureComponent } from 'react';
import { Animated, Image, StyleSheet, PanResponder, View, Text, Platform } from 'react-native';
import variables from '../../common/styles/variables';
import sliderStyles from './styles';
import Coord from './Coord';

var thumbImage = require('./images/rectangle.png');

var otherThumbImage = require('./images/rectangle.png');

var styles = StyleSheet.create(sliderStyles);

var Slider =
/*#__PURE__*/
function (_PureComponent) {
  _inheritsLoose(Slider, _PureComponent);

  function Slider(props) {
    var _this;

    _this = _PureComponent.call(this, props) || this;

    _this.getValueByProps = function (isOther) {
      var _this$props = _this.props,
          value = _this$props.value,
          range = _this$props.range;

      if (range && value instanceof Array) {
        if (isOther) {
          return value[1];
        }

        return value[0];
      }

      return value;
    };

    _this.thumbTouchCheck = function (e) {
      var nativeEvent = e.nativeEvent;
      var range = _this.props.range;

      if (range) {
        var otherThumbCoord = _this.getThumbCoord(range);

        var otherCheckResult = otherThumbCoord.contain(nativeEvent.locationX, nativeEvent.locationY);

        if (otherCheckResult) {
          _this.isOther = true;
          return otherCheckResult;
        }
      }

      var ThumbCoord = _this.getThumbCoord();

      var checkResult = ThumbCoord.contain(nativeEvent.locationX, nativeEvent.locationY);

      if (checkResult) {
        _this.isOther = false;
        return checkResult;
      }

      return false;
    };

    _this.getThumbCoord = function (isOther) {
      var _this$state = _this.state,
          thumbSize = _this$state.thumbSize,
          otherThumbSize = _this$state.otherThumbSize,
          containerSize = _this$state.containerSize;
      var currThumb = thumbSize;

      if (isOther) {
        currThumb = otherThumbSize;
      }

      var vertical = _this.props.vertical;
      var x = null;
      var y = null;

      if (vertical) {
        x = (containerSize.width - currThumb.width) / 2;
        y = _this.getThumbLeft(_this.getCurrentValue(isOther));
      } else {
        x = _this.getThumbLeft(_this.getCurrentValue(isOther));
        y = (containerSize.height - currThumb.height) / 2;
      }

      return new Coord(x, y, currThumb.width, currThumb.height);
    };

    _this.scroll = function (gestureState) {
      if (_this.props.disabled) {
        return;
      }

      if (_this.isOther) {
        var isOtherValue = _this.getValue(gestureState, _this.isOther);

        _this.setCurrentValue(isOtherValue, _this.isOther);
      } else {
        var _value = _this.getValue(gestureState);

        _this.setCurrentValue(_value);
      }
    };

    _this.touchStart = function (e) {
      _this.oldValue = _this.state.value.__getValue();
      _this.oldOtherValue = _this.state.otherValue.__getValue();
      return _this.thumbTouchCheck(e);
    };

    _this.pressStart = function () {
      if (_this.isOther) {
        _this.otherPreviousLeft = _this.getThumbLeft(_this.getCurrentValue(_this.isOther));
      } else {
        _this.previousLeft = _this.getThumbLeft(_this.getCurrentValue());
      }
    };

    _this.lastMove = function (_, gestureState) {
      _this.scroll(gestureState);
    };

    _this.touchEnd = function (_, gestureState) {
      _this.scroll(gestureState);

      if (_this.oldValue !== _this.getCurrentValue()) {
        _this.triggerEvent('onChange');
      }

      if (_this.props.range && _this.oldOtherValue !== _this.getCurrentValue(true)) {
        _this.triggerEvent('onChange');
      }
    };

    _this.measureContainer = function (x) {
      _this.handleMeasure('containerSize', x);
    };

    _this.measureTrack = function (x) {
      _this.handleMeasure('trackSize', x);
    };

    _this.measureThumb = function (x) {
      _this.handleMeasure('thumbSize', x);
    };

    _this.measureOtherThumb = function (x) {
      _this.handleMeasure('otherThumbSize', x);
    };

    _this.handleMeasure = function (name, x) {
      var _newState;

      var _x$nativeEvent$layout = x.nativeEvent.layout,
          width = _x$nativeEvent$layout.width,
          height = _x$nativeEvent$layout.height;
      var size = {
        width: width,
        height: height
      };
      var currentSize = _this.state[name];

      if (currentSize && width === currentSize.width && height === currentSize.height) {
        return;
      }

      var newState = (_newState = {}, _newState[name] = size, _newState); // 双滑块

      _this.setState(newState);
    };

    _this.getScrollLength = function () {
      var vertical = _this.props.vertical;
      var trackSize = _this.state.trackSize;

      if (vertical) {
        return trackSize.height;
      } else {
        return trackSize.width;
      }
    };

    _this.getThumbOffset = function (isOther) {
      var vertical = _this.props.vertical;
      var _this$state2 = _this.state,
          thumbSize = _this$state2.thumbSize,
          otherThumbSize = _this$state2.otherThumbSize;

      if (vertical && isOther) {
        return otherThumbSize.height;
      } else if (!vertical && isOther) {
        return otherThumbSize.width;
      } else if (vertical && !isOther) {
        return thumbSize.height;
      } else if (!vertical && !isOther) {
        return thumbSize.height;
      }
    };

    _this.getRatio = function (value) {
      var _this$props2 = _this.props,
          min = _this$props2.min,
          max = _this$props2.max;

      if (max === min) {
        return 0;
      }

      return (value - min) / (max - min);
    };

    _this.getThumbLeft = function (value) {
      var vertical = _this.props.vertical;

      var ratio = _this.getRatio(value);

      if (vertical) {
        ratio = 1 - ratio;
      }

      var scrollLength = _this.getScrollLength();

      return ratio * scrollLength;
    };

    _this.showStep = function () {
      var _this$props3 = _this.props,
          vertical = _this$props3.vertical,
          step = _this$props3.step,
          range = _this$props3.range;

      if (!range && !vertical && step) {
        return true;
      }

      return false;
    };

    _this.getValue = function (gestureState, isOther) {
      var previousLeft = _this.previousLeft;

      if (isOther) {
        previousLeft = _this.otherPreviousLeft;
      }

      var scrollLength = _this.getScrollLength();

      var _this$props4 = _this.props,
          step = _this$props4.step,
          min = _this$props4.min,
          max = _this$props4.max,
          vertical = _this$props4.vertical;
      var thumbLeft = null;

      if (vertical) {
        thumbLeft = previousLeft + gestureState.dy;
      } else {
        thumbLeft = previousLeft + gestureState.dx;
      }

      var ratio = thumbLeft / scrollLength;

      if (vertical) {
        ratio = 1 - ratio;
      }

      if (_this.showStep()) {
        return Math.max(min, Math.min(max, min + Math.round(ratio * (max - min) / step) * step));
      }

      return Math.max(min, Math.min(max, ratio * (max - min) + min));
    };

    _this.getCurrentValue = function (isOther) {
      var value = _this.state.value;

      if (isOther) {
        value = _this.state.otherValue;
      }

      return value.__getValue();
    };

    _this.setCurrentValue = function (value, isOther) {
      if (isOther) {
        _this.setState({
          otherTip: "" + Math.round(value)
        });

        _this.state.otherValue.setValue(value);
      } else {
        _this.setState({
          tip: "" + Math.round(value)
        });

        _this.state.value.setValue(value);
      }
    };

    _this.triggerEvent = function (event) {
      if (_this.props[event]) {
        var args = [Math.round(_this.getCurrentValue())];
        var range = _this.props.range;

        if (range) {
          if (_this.compareValue()) {
            args.unshift(Math.round(_this.getCurrentValue(range)));
          } else {
            args.push(Math.round(_this.getCurrentValue(range)));
          }

          _this.props[event](args);
        } else {
          _this.props[event](args[0]);
        }
      }
    };

    _this.renderThumbImage = function (isOther) {
      if (!isOther && !thumbImage) return;
      if (isOther && !otherThumbImage) return;
      var renderThumb = _this.props.renderThumb;
      var thumbSize = _this.state.thumbSize;

      if (typeof renderThumb === 'function') {
        return renderThumb(isOther);
      }

      return React.createElement(Image, {
        style: [thumbSize, {
          borderRadius: _this.getThumbOffset() / 2
        }],
        source: isOther ? otherThumbImage : thumbImage
      });
    };

    _this.renderMarks = function () {
      var _this$props5 = _this.props,
          step = _this$props5.step,
          marks = _this$props5.marks,
          min = _this$props5.min,
          max = _this$props5.max,
          thumbSize = _this$props5.thumbSize;

      if (!_this.showStep() || !marks) {
        return null;
      }

      var maxStep = Math.ceil(Math.abs((max - min) / step)) + 1;
      var currStep = 0;
      var markViewArr = [];

      while (maxStep > currStep) {
        if (React.isValidElement(marks[currStep])) {
          markViewArr.push(marks[currStep]);
        } else {
          markViewArr.push(React.createElement(View, {
            key: currStep,
            style: {
              width: thumbSize,
              alignItems: 'center'
            }
          }, React.createElement(Text, {
            style: styles.markItemText
          }, marks[currStep]), React.createElement(View, {
            style: styles.markItemLine
          })));
        }

        currStep += 1;
      }

      return React.createElement(View, {
        style: styles.markContainer
      }, markViewArr);
    };

    _this.renderThumbToolTip = function (isOther) {
      var _this$props6 = _this.props,
          showTip = _this$props6.showTip,
          renderTip = _this$props6.renderTip;

      if (!showTip) {
        return;
      }

      var _this$state3 = _this.state,
          tip = _this$state3.tip,
          otherTip = _this$state3.otherTip;
      return React.createElement(View, {
        style: [styles.tip // this.showAndroidTip ? { top: 0, marginTop: 0, height: 100 } : {}
        ]
      }, React.createElement(View, {
        key: 1,
        style: styles.tipContent
      }, renderTip ? renderTip(isOther ? otherTip : tip) : React.createElement(Text, {
        style: styles.tipText
      }, isOther ? otherTip : tip)), React.createElement(View, {
        key: 2,
        style: styles.tipIcon
      }));
    };

    _this.getScrollRange = function () {
      var scrollLength = _this.getScrollLength();

      return [0, scrollLength];
    };

    _this.renderThumb = function (isOther) {
      var _this$props7 = _this.props,
          vertical = _this$props7.vertical,
          range = _this$props7.range;
      if (isOther && !range) return;
      var _this$state4 = _this.state,
          value = _this$state4.value,
          otherValue = _this$state4.otherValue,
          thumbSize = _this$state4.thumbSize,
          otherThumbSize = _this$state4.otherThumbSize;
      var currValue = value;
      var currThumb = thumbSize;
      var measureFn = _this.measureThumb;

      if (isOther) {
        currValue = otherValue;
        currThumb = otherThumbSize;
        measureFn = _this.measureOtherThumb;
      }

      var thumbLeft = _this.getThumbLeft(currValue.__getValue());

      var thumbStyle = {
        transform: [{
          translateX: thumbLeft
        }, {
          translateY: 0
        }],
        alignItems: 'center',
        borderRadius: _this.getThumbOffset(isOther) / 2
      };

      if (vertical) {
        thumbStyle.transform = [{
          translateX: 0
        }, {
          translateY: thumbLeft
        }];
      }

      if (_this.showAndroidTip) {
        return React.createElement(Animated.View, {
          onLayout: measureFn,
          renderToHardwareTextureAndroid: true,
          style: [styles.thumb, thumbStyle]
        }, _this.renderThumbToolTip(isOther), React.createElement(View, {
          style: [currThumb, {
            borderRadius: _this.getThumbOffset(isOther) / 2
          }]
        }, _this.renderThumbImage(isOther)));
      }

      return React.createElement(Animated.View, {
        onLayout: measureFn,
        renderToHardwareTextureAndroid: true,
        style: [styles.thumb, currThumb, thumbStyle]
      }, _this.renderThumbToolTip(isOther), _this.renderThumbImage(isOther));
    };

    _this.compareValue = function () {
      var range = _this.props.range;
      return range && _this.getCurrentValue() >= _this.getCurrentValue(true);
    };

    _this.getTrackColor = function (isOther) {
      var _this$props8 = _this.props,
          minTrackColor = _this$props8.minTrackColor,
          midTrackColor = _this$props8.midTrackColor,
          maxTrackColor = _this$props8.maxTrackColor,
          range = _this$props8.range,
          vertical = _this$props8.vertical;
      var activeColor = ''; // 双滑块B

      if (isOther) {
        if (_this.compareValue()) {
          if (vertical) {
            // 纵向双滑块A>=B B => midTrackColor
            activeColor = midTrackColor;
          } else {
            // 横向双滑块A>=B B => minTrackColor
            activeColor = minTrackColor;
          }
        } else {
          if (vertical) {
            // 纵向双滑块A<B B => trackColor
            activeColor = maxTrackColor;
          } else {
            // 横向双滑块A<B B => midTrackColor
            activeColor = midTrackColor;
          }
        } // 双滑块A

      } else if (range) {
        if (_this.compareValue()) {
          if (vertical) {
            // 纵向双滑块A<B A => trackColor
            activeColor = maxTrackColor;
          } else {
            // 横向双滑块A<B A => midTrackColor
            activeColor = midTrackColor;
          }
        } else {
          if (vertical) {
            // 纵向双滑块A>=B A => midTrackColor
            activeColor = midTrackColor;
          } else {
            // 横向单滑块A>=B A => minTrackColor
            activeColor = minTrackColor;
          }
        } // 单滑块

      } else {
        if (vertical) {
          // 纵向单滑块 A => trackColor
          activeColor = maxTrackColor;
        } else {
          // 横向单滑块 A => minTrackColor
          activeColor = minTrackColor;
        }
      }

      return [activeColor];
    };

    _this.renderMinimumTrack = function (isOther) {
      var _this$props9 = _this.props,
          disabled = _this$props9.disabled,
          range = _this$props9.range,
          vertical = _this$props9.vertical,
          trackWeight = _this$props9.trackWeight;
      if (isOther && !range) return;
      var _this$state5 = _this.state,
          value = _this$state5.value,
          otherValue = _this$state5.otherValue;
      var currValue = value;
      var minimumTrackColor = null;
      var currKey = 'minTrack';

      if (isOther) {
        currValue = otherValue;
        currKey = 'otherMinTrack';
      }

      var minimumTrackWidth = _this.getThumbLeft(currValue.__getValue()); // 滑轨颜色值设定


      var trackColors = _this.getTrackColor(isOther);

      minimumTrackColor = trackColors[0];
      var minimumTrackStyle = {
        position: 'absolute',
        backgroundColor: minimumTrackColor
      };
      var trackStyle = null;

      if (vertical) {
        minimumTrackStyle.height = minimumTrackWidth;
        minimumTrackStyle.width = _this.props.trackWeight;
        trackStyle = {
          marginVertical: _this.getThumbOffset(isOther) / 2
        };
      } else {
        minimumTrackStyle.height = _this.props.trackWeight;
        minimumTrackStyle.width = minimumTrackWidth;
        trackStyle = {
          marginHorizontal: _this.getThumbOffset(isOther) / 2
        };
      }

      return React.createElement(Animated.View, {
        key: currKey,
        renderToHardwareTextureAndroid: true,
        style: [{
          borderRadius: trackWeight / 2
        }, minimumTrackStyle, trackStyle]
      });
    };

    _this.getTrackStyle = function () {
      var _this$props10 = _this.props,
          range = _this$props10.range,
          vertical = _this$props10.vertical,
          maxTrackColor = _this$props10.maxTrackColor,
          minTrackColor = _this$props10.minTrackColor,
          trackWeight = _this$props10.trackWeight,
          thumbSize = _this$props10.thumbSize;
      var trackStyle = {
        backgroundColor: maxTrackColor
      };
      var marginArr = ['marginLeft', 'marginRight', 'marginHorizontal', 'height'];
      var rest = thumbSize - trackWeight;
      var spacing = rest > 0 ? Math.ceil(rest / 2) : 0;

      if (vertical) {
        marginArr = ['marginTop', 'marginBottom', 'marginVertical', 'width'];
        trackStyle.flex = 1;
        trackStyle.alignItems = 'flex-start';
        trackStyle.backgroundColor = minTrackColor;
        trackStyle.marginHorizontal = spacing;
      } else {
        trackStyle.marginVertical = spacing;
      } // 样式处理


      if (range) {
        trackStyle[marginArr[0]] = _this.getThumbOffset() / 2;
        trackStyle[marginArr[1]] = _this.getThumbOffset(true) / 2;
      } else {
        trackStyle[marginArr[2]] = _this.getThumbOffset() / 2;
      }

      trackStyle[marginArr[3]] = _this.props.trackWeight;
      return trackStyle;
    };

    _this.renderTracks = function () {
      var _this$props11 = _this.props,
          vertical = _this$props11.vertical,
          trackWeight = _this$props11.trackWeight;

      var trackStyle = _this.getTrackStyle(); // 如果value > oldValue，则代表两个滑块滑动位置互换，则更新渲染层级


      var tracks = [React.createElement(View, {
        style: [{
          borderRadius: trackWeight / 2
        }, trackStyle],
        onLayout: _this.measureTrack,
        key: 'track'
      })]; // vertical的值和this.compareValue()值相同时，次滑块轴在底层，反之主滑块轴在底层

      if (vertical === _this.compareValue()) {
        tracks.push(_this.renderMinimumTrack(true));
        tracks.push(_this.renderMinimumTrack());
      } else {
        tracks.push(_this.renderMinimumTrack());
        tracks.push(_this.renderMinimumTrack(true));
      }

      return tracks;
    };

    _this.state = {
      containerSize: {
        width: 0,
        height: 0
      },
      trackSize: {
        width: 0,
        height: 0
      },
      thumbSize: {
        width: props.thumbSize,
        height: props.thumbSize
      },
      otherThumbSize: {
        width: props.thumbSize,
        height: props.thumbSize
      },
      value: new Animated.Value(_this.getValueByProps()),
      otherValue: new Animated.Value(_this.getValueByProps(true)),
      tip: "" + _this.getValueByProps(),
      otherTip: "" + _this.getValueByProps(true)
    };
    _this.isOther = false;
    _this.showAndroidTip = _this.props.showTip && Platform.OS === 'android';
    return _this;
  }

  var _proto = Slider.prototype;

  _proto.componentWillMount = function componentWillMount() {
    this.panResponder = PanResponder.create({
      onStartShouldSetPanResponder: this.touchStart,
      onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(_) {
        return false;
      },
      onPanResponderGrant: this.pressStart,
      onPanResponderMove: this.lastMove,
      onPanResponderRelease: this.touchEnd,
      onPanResponderTerminationRequest: function onPanResponderTerminationRequest(_) {
        return false;
      },
      onPanResponderTerminate: this.touchEnd
    });
  };

  _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var newValue = 0;
    var newOtherValue = 0;
    var range = this.props.range;

    if (range && nextProps.value instanceof Array) {
      newValue = nextProps.value[0];
      newOtherValue = nextProps.value[1];
    } else {
      newValue = nextProps.value;
    }

    if (this.getValueByProps() !== newValue) {
      this.setCurrentValue(newValue);
    }

    if (range && this.getValueByProps(true) !== newOtherValue) {
      this.setCurrentValue(newOtherValue, range);
    }
  }
  /**
   * 通过props获取滑块对应的value值
   */
  ;

  _proto.render = function render() {
    var _this$props12 = this.props,
        style = _this$props12.style,
        vertical = _this$props12.vertical;
    return React.createElement(View, {
      style: [{
        flexDirection: vertical ? 'row' : 'column'
      }, style]
    }, this.renderMarks(), React.createElement(View, {
      style: {
        alignItems: vertical ? 'center' : undefined,
        justifyContent: vertical ? undefined : 'center'
      },
      onLayout: this.measureContainer
    }, this.renderTracks(), this.renderThumb(), this.renderThumb(true), React.createElement(View, _extends({
      renderToHardwareTextureAndroid: true,
      style: styles.touchArea
    }, this.panResponder.panHandlers))));
  };

  return Slider;
}(PureComponent);

Slider.defaultProps = {
  value: 0,
  min: 0,
  max: 1,
  step: 0,
  maxTrackColor: variables.hyFillGray,
  minTrackColor: variables.hyBrandPrimary,
  midTrackColor: variables.hyBrandDanger,
  range: false,
  vertical: false,
  showTip: false,
  trackWeight: 5,
  thumbSize: 30
};
export { Slider as default };