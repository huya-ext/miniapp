function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_OPTIONS = {
  idKey: 'id',
  pIdKey: 'pId',
  childrenKey: 'children',
  type: 'nested',
  // nested flattened
  data: []
};

function Tree(options) {
  this.options = _objectSpread({}, DEFAULT_OPTIONS, {}, options);
  var type = options.type,
      data = options.data;
  this.data = [].concat(this.parse(type, data));
}

Tree.prototype.parse = function () {
  return this[arguments[0] + 'Parser'].call(this, arguments[1]);
};

Tree.prototype.nestedParser = function (data) {
  var ret = deepFirstRecursive.call(this, data);
  return ret;
  /**
   * 深度优先
   *       +-D
   *   +-B-|
   * A-|   +-E
   *   +-C-F
   *
   * 找到 B 节点后把 B 作为父节点，children 数组作为数据，进入下次递归
   */

  function deepFirstRecursive(data, pItem, unique) {
    var _this = this;

    pItem = pItem || null;
    unique = unique || {
      id: 1
    };
    var result = [];
    data.forEach(function (item) {
      var tmpItem = _objectSpread({}, item); // 没有唯一标志时增加一个


      if (tmpItem[_this.options.idKey] == null) {
        tmpItem[_this.options.idKey] = unique.id++;
      } // 没有对父节点的引用关系时增加一个


      if (pItem && tmpItem[_this.options.pIdKey] == null) {
        tmpItem[_this.options.pIdKey] = pItem[_this.options.idKey];
      }

      result.push(tmpItem);

      if (tmpItem[_this.options.childrenKey] && tmpItem[_this.options.childrenKey].length) {
        var children = tmpItem[_this.options.childrenKey];
        tmpItem[_this.options.childrenKey] = children.map(function (child) {
          return child[_this.options.idKey];
        });
        var restList = deepFirstRecursive.call(_this, children, tmpItem, unique);
        result = result.concat(restList);
      }
    });
    return result;
  }
};

Tree.prototype.getData = function () {
  return this.data;
};

Tree.prototype.flattenedParser = function (data) {
  var _this2 = this;

  var result = data.concat();
  data.forEach(function (item) {
    if (item[_this2.options.pIdKey]) {
      result = result.map(function (tmpItem) {
        if (tmpItem[_this2.options.idKey] === item[_this2.options.pIdKey]) {
          var _objectSpread2;

          return _objectSpread({}, tmpItem, (_objectSpread2 = {}, _objectSpread2[_this2.options.childrenKey] = [].concat(tmpItem[_this2.options.childrenKey] || []).concat(item[_this2.options.idKey]), _objectSpread2));
        } else {
          return tmpItem;
        }
      });
    }
  });
  return result;
};

export default Tree;